package main

import (
	"fmt"
	"os"
)

// Dlltool - Create files needed to build and use DLLs (GNU dlltool equivalent)

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s <option> <dll-file>\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Options: --def, --output-lib, --output-exp\n")
		os.Exit(1)
	}

	option := os.Args[1]
	dllFile := os.Args[2]

	switch option {
	case "--def":
		if len(os.Args) < 4 {
			fmt.Fprintf(os.Stderr, "Error: missing output file\n")
			os.Exit(1)
		}
		if err := generateDefFile(dllFile, os.Args[3]); err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}

	case "--output-lib":
		if len(os.Args) < 4 {
			fmt.Fprintf(os.Stderr, "Error: missing output file\n")
			os.Exit(1)
		}
		if err := generateImportLibrary(dllFile, os.Args[3]); err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}

	case "--output-exp":
		if len(os.Args) < 4 {
			fmt.Fprintf(os.Stderr, "Error: missing output file\n")
			os.Exit(1)
		}
		if err := generateExportFile(dllFile, os.Args[3]); err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}

	default:
		fmt.Fprintf(os.Stderr, "Unknown option: %s\n", option)
		os.Exit(1)
	}
}

// generateDefFile generates .def file from DLL
func generateDefFile(dllFile, outputFile string) error {
	// Secure: validate filenames
	if len(dllFile) > 255 || len(outputFile) > 255 {
		return fmt.Errorf("filename too long")
	}

	file, err := os.Open(dllFile)
	if err != nil {
		return fmt.Errorf("failed to open DLL: %w", err)
	}
	defer file.Close()

	// Read DLL header (PE format)
	header := make([]byte, 64)
	if _, err := file.Read(header); err != nil {
		return fmt.Errorf("failed to read DLL header: %w", err)
	}

	// Secure: validate PE signature
	if len(header) < 2 || header[0] != 'M' || header[1] != 'Z' {
		return fmt.Errorf("not a valid PE file")
	}

	// Generate .def file content
	defContent := fmt.Sprintf("LIBRARY %s\n", getBaseName(dllFile))
	defContent += "DESCRIPTION \"Generated by dlltool\"\n"
	defContent += "EXPORTS\n"
	defContent += "\tDllMain\n"

	// Secure: validate content size
	if len(defContent) > 10*1024*1024 {
		return fmt.Errorf("def file too large")
	}

	return os.WriteFile(outputFile, []byte(defContent), 0644)
}

// Archive types for dlltool
type dlltoolArchiveHeader struct {
	Name    string
	Date    int64
	UID     int
	GID     int
	Mode    int
	Size    int64
	EndChar [2]byte
}

type dlltoolArchiveMember struct {
	Header dlltoolArchiveHeader
	Data   []byte
}

// generateImportLibrary generates import library from DLL
func generateImportLibrary(dllFile, outputFile string) error {
	// Secure: validate filenames
	if len(dllFile) > 255 || len(outputFile) > 255 {
		return fmt.Errorf("filename too long")
	}

	// Create minimal import library (archive format)
	members := map[string]*dlltoolArchiveMember{
		"dll_import.o": {
			Header: dlltoolArchiveHeader{
				Name: "dll_import.o",
				Date: 0,
				UID:  0,
				GID:  0,
				Mode: 0644,
				Size: 0,
			},
			Data: []byte{},
		},
	}

	// Use writeArchive from ar.go (same package)
	// Write archive using ar.go functions (same package)
	// For standalone build, implement minimal write
	return writeArchiveForDlltool(outputFile, members)
}

// writeArchiveForDlltool writes archive (minimal implementation)
func writeArchiveForDlltool(archiveName string, members map[string]*dlltoolArchiveMember) error {
	file, err := os.Create(archiveName)
	if err != nil {
		return fmt.Errorf("failed to create archive: %w", err)
	}
	defer file.Close()

	// Write magic
	if _, err := file.WriteString("!<arch>\n"); err != nil {
		return fmt.Errorf("failed to write magic: %w", err)
	}

	// Write members (simplified)
	for _, member := range members {
		// Write minimal header
		header := make([]byte, 60)
		copy(header[0:16], []byte(member.Header.Name))
		copy(header[48:58], []byte(fmt.Sprintf("%d", member.Header.Size)))
		copy(header[58:60], []byte("`\n"))
		file.Write(header)
		file.Write(member.Data)
		if len(member.Data)%2 != 0 {
			file.Write([]byte{'\n'})
		}
	}

	return nil
}

// generateExportFile generates export file from DLL
func generateExportFile(dllFile, outputFile string) error {
	// Secure: validate filenames
	if len(dllFile) > 255 || len(outputFile) > 255 {
		return fmt.Errorf("filename too long")
	}

	// Generate export file content
	exportContent := fmt.Sprintf("EXPORTS\n")
	exportContent += fmt.Sprintf("DllMain @1\n")

	// Secure: validate content size
	if len(exportContent) > 10*1024*1024 {
		return fmt.Errorf("export file too large")
	}

	return os.WriteFile(outputFile, []byte(exportContent), 0644)
}

// getBaseName extracts base name from path
func getBaseName(path string) string {
	// Secure: prevent path traversal
	if len(path) == 0 {
		return "unknown"
	}

	// Find last separator
	lastSlash := -1
	for i := len(path) - 1; i >= 0; i-- {
		if path[i] == '/' || path[i] == '\\' {
			lastSlash = i
			break
		}
	}

	if lastSlash >= 0 && lastSlash < len(path)-1 {
		return path[lastSlash+1:]
	}

	return path
}
